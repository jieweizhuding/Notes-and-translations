连续分配存储管理方式是规定元件在内存中必须连接存储。而下一个分页存储规定元件可以在内存中分开存储。
## 连续分配方式
#### 单一连续分配
即将内存分为系统区与用户区两部分，系统区供给OS使用，用户区只装有一道程序。内存使用率低。
#### 固定分区分配
将内存划分为固定大小的分区，即分区的个数是固定的，分区的大小可以相等，也可以不等。为了便于内存分配，通常按照分区的大小对其排队，建立一张分区使用表。该表的长度确定且不会改变。这是与后面的分配方式的差异之处。
#### 动态分区分配
根据进程的实际需要，动态地分配内存。当有内存被释放，并被给予给新的进程时就会产生碎片，但与固定分区分配相比，内存利用率大幅提高。
为了管理分区，常用的数据结构有
1. 空闲分区表
2. 空闲分区链

实际上与固定分区的分区使用表类似，仅仅是长度不定。
下面是动态分区的单一分区分配算法：
![alt text](https://pic4.zhimg.com/v2-403b92ec7964a61abfb3a6ec42478b37_1440w.jpg)
回收算法：
![alt text](https://pic2.zhimg.com/v2-d7ae1fba3e89582282527c644fc0dad1_1440w.jpg)

为了提高内存的利用率，我们会使用一些内存分配算法。常见的有：
1. 顺序式搜索算法
[顺序式搜索算法](https://blog.csdn.net/weixin_43886592/article/details/107581653)
    1. FF算法（首次适应算法）
    2. NF算法（循环首次使用算法）
    3. BF算法（最佳适应算法）
    4. WF算法（最坏适应算法）
2. 索引式搜索算法
    1. QF算法（快速适应算法）
    2. 伙伴系统
    3. 哈希算法

这里索引式搜索算法不做重点要求，且实际上思想与哈希查找或桶排序类似，就是按照大类分类，再从大类中一点点找到准确的结果。

#### 动态可重定位分区分配
因为上方的分配方式会产生大量的碎片，故希望将碎片放在一起，组成一个大的可用空间。该过程就是紧凑的思想。动态可重定位分区分配就是利用紧凑来解决问题的。但实际上，紧凑操作的时间复杂度很高，是用时间换空间的操作。