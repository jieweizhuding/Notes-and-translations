翻译自pitchfork
URL：https://github.com/vector-of-bool/pitchfork/blob/develop/data/spec.bs

# 1.引言 
“没关系，只要保持一致就行”这句话对 C++ 社区的伤害远大于帮助。可以说，这是一种“愚蠢的一致性”。开发者希望保持其代码库独特和“特殊”的愿望，阻碍了工具的发展，因为每个用户都坚持要求工具支持他们自己的自定义风格。

对于某些事情，比如你把左大括号放在哪里，差异可能真的无关紧要。但对于其他事情，情况并非如此。

其中之一就是项目在文件系统中的布局。

不一致的布局不仅损害了工具，还造成了不必要的差异，增加了贡献者加入时的摩擦，并为初学者带来了巨大的负担，而这本应是几秒钟就能决定的事情。

对于几乎所有项目来说，它们都是几个关键组件的某种（可能不正确的）子集：
*    可编译的源文件
*    公共头文件
*    私有头文件
*    包含入口点（main() 函数）的源文件
*    文档文件
*    测试文件
*    示例和演示代码
*    嵌入项目结构中的外部库
*    源代码的“附加组件”（例如语言绑定、可选插件、平台绑定）

此外，常见的情况是项目将自己划分为子模块。这些子模块之间也可能存在依赖关系。子模块大大增加了潜在的复杂性，但并非完全不可行。项目布局标准必须能够处理划分后的项目。

## 1.1 背景与术语
本文提出的想法和概念并非新颖。相反，它们建立在他人工作的基础上。有些来自专业的想法和经验，而另一些则来自社区惯例，这些惯例逐渐趋向于偏好某些模式，同时摒弃其他模式。

### 1.1.1 物理布局与逻辑布局
本文档大量借鉴了 John Lakos 的工作，他在物理设计方面做出了许多贡献。在逻辑设计领域已经有很多工作，但物理设计至今仍然是一个（在作者看来）在系统设计和实现以及教学过程中经常被忽视的话题。

John Lakos 于 1996 年出版的《大规模 C++ 软件设计》一书，至今仍然是 C++ 物理设计领域的权威著作。

那么，物理设计和逻辑设计有什么区别呢？

逻辑设计与系统设计中与编程语言相关的方面密切相关。

物理设计则涉及语言编码之外的系统设计方面。

C 和 C++ 标准处理的源单元是翻译单元。这对应于一个已经解析了所有预处理器指令的源文件。这是语言标准最接近讨论系统物理设计的地方。

当然，物理设计尽管名字如此，仍然存在于数字空间中。它涉及文件系统中文件和目录的放置和命名，以及如何协调物理单元之间的通信，而这些单元在文件系统中的位置关系并不是确定的。

本文档并未涉及太多逻辑设计的内容。相反，它专门针对物理设计中的许多常见问题提供解答，并解决常见的困惑。

### 1.1.2 物理组件 

物理设计中最基本的单元是组件。

一个组件应该严格对应两个文件：一个头文件和一个源文件。在某些罕见情况下，单个物理组件中使用多个源文件可能是有益的，但这可能表明需要进一步的重构。

此外，一个组件可能有一个测试源文件，但它不被视为物理组件的一部分。
### 1.1.3 逻辑/物理一致性 

本文档假设开发者会努力保持逻辑/物理的一致性。系统的逻辑组件和物理组件之间必须存在一致的关系，单个逻辑组件不能分散在多个物理组件中。多个逻辑组件也不应出现在同一个物理组件中。
```
注意：逻辑组件可以包含多个类或函数。
例如，它可能包括表示私有数据的类（用于 PIMPL 模式）或 friend 类和函数。
盲目地将每个类和函数拆分为单独的物理组件既不必要，也不推荐。
```

物理组件之间不能形成循环依赖。

EXAMPLE_1
**Example of friendship**
```c++
// list.hpp
namespace acme {

template <typename T>
class list;

namespace detail {

// Class implementing a "list iterator"
template <typename T>
class list_iterator {
public:
    // Public default constructor
    list_iterator() = default;

private:
    // A private constructor used to initialize the iterator to the proper state
    explicit list_iterator(list<T>&);

    // Permit our list class to construct us with the private constructor
    friend class list<T>;
};

}

template <typename T>
class list {
public:
    using iterator = detail::list_iterator<T>;

    // The iterator class is a friend, giving it access to our internals
    friend class detail::list_iterator<T>;
};

}
```

除了一个包含指令外，list.cpp 是空的：

```c++
// list.cpp
#include "list.hpp"
```

空的 list.cpp 文件的目的是确保 list.hpp 文件能够独立编译，从而确保头文件包含了必要的 #include 指令和/或前向声明。

尽管有两个不同的语言级 class 模板，但它们属于一个逻辑组件。我们说这两个类模板是“共置的”。

我们还有两个源文件，list.hpp 和 list.cpp，但它们共同构成了一个物理组件。


EXAMPLE_2
**Example using PIMPL**
```c++
// connection.hpp
#include <memory>

namespace acme {

// Forward-declare the private member data type
namespace detail { class connection_ipml; }

// The wrapper class
class connection {
private:
    // The actual PIMPL
    std::unique_ptr<detail::connection_impl> _impl;

public:
    connection(const std::string& address);
    ~connection();
};

}
```

以及相应的 connection.cpp：

```c++
#include "connection.hpp"

namespace acme::detail {

class connection_impl {
    // Whatever we need for the connection...
};

}

namespace {

std::unique_ptr<acme::detail::connection_impl>
init_private_data(const std::string& address) {
    // Initialize and return the connection data...
}

}

acme::connection::~connection() = default;
acme::connection::connection(const std::string& address)
    : _impl{ init_private_data(address) }
{}
```

这里我们再次有两个不同的（非 template）类，但它们属于一个逻辑组件。在头文件中，实现细节类只是进行了前向声明，而没有完整定义。在 connection.cpp 文件中，我们提供了细节类的定义。

### 1.1.4 包、项目、模块和子模块 

前面几节中定义的术语大量借鉴了 John Lakos 的工作。他的工作中也经常使用术语包来指代一组源组件。这大致对应于整个源代码仓库，包括构建文件、支持文件、文档、脚本和数据。

不幸的是，“包”这个术语已经被过度使用。如今，“包”通常指的是软件的发布单元，而不是软件本身。因此，本文档更倾向于使用“项目”这个术语，并会用它来代替“包”，尽管它们的含义相同。

同样地，术语模块也被过度使用。随着即将到来的 C++ 模块规范和实现，“模块”这个词将被避免使用，以免产生歧义和混淆，因为“模块”既不对应于包/项目，也不对应于物理组件。

尽管如此，仍然需要一个术语来指代将大型项目划分为较小部分的情况。例如，Qt 是一个由许多相互连接的部分组成的庞大框架。为了指代这些部分，Qt 使用了“模块”这个术语，但这个词已经被排除了。

由于缺乏更好的未限定术语，本文作者能找到的最佳选择是一个限定术语：子模块。这个术语将用于表示项目中可以按需使用的独立部分。更多信息请参见 下文的 4. Submodules 

## 1.2 项目文件 

PFL 规定了一些应该存在于项目根目录中的文件：

    应该有一个 README 文件。它应该易于以纯文本形式阅读，但可以使用“增强”的纯文本格式，如 Markdown 或类似格式。它应包含对目录和子目录内容的描述。

    对于希望重新发布的项目，必须有一个 LICENSE 文件。它必须是纯文本格式（即不能使用标记语言增强）。

工具支持文件，如 .gitignore 和 .clang-format，可以存在于该目录中。

根目录中的其他文件必须与项目的构建系统相关。其他文件不应出现在项目的根目录中。

## 1.3 项目目录 

PFL 规定了一些应该出现在项目根目录中的目录。并非所有目录都是必需的，但它们有指定的用途，文件系统中的其他目录不能承担这些目录的角色。也就是说，如果需要这些目录的用途，必须使用这些目录。

其他目录不应出现在根目录中。
```
注意：如果你有未被以下列出的 PFL 目录满足的需求，那是本规范的一个缺陷，我非常乐意听取你的意见！在报告之前，请仔细检查你需要的目录是否未在以下部分列出。
```
目录说明

    build/

        一个特殊目录，不应被视为项目源代码的一部分。用于存储临时构建结果。

        不得提交到源代码控制中。如果使用源代码控制，必须通过源代码控制的忽略列表忽略此目录。

    src/

        主要的可编译源代码位置。对于具有编译组件且不使用子模块的项目，必须存在此目录。

        如果存在 include/ 目录，则 src/ 也包含私有头文件。

    include/

        公共头文件的目录。可以存在。对于不区分私有/公共头文件的项目，可以省略。对于使用子模块的项目，可以省略。

    tests/

        测试文件的目录。

    examples/

        示例和演示代码的目录。

    external/

        用于存放项目使用但不作为项目一部分编辑的包/项目的目录。

    extras/

        包含项目的额外/可选子模块的目录。

    data/

        包含项目非源代码方面的目录。可能包括图形和标记文件。

    tools/

        包含开发工具的目录，例如构建和重构脚本。

    docs/

        项目文档的目录。

    libs/

        主项目子模块的目录。


# 2.顶级目录

Pitchfork 规定了几个顶级目录。除了其他工具所需的目录外，根目录中不应存在其他目录。

## 2.1. build/

此目录不是必需的，但其名称应被保留。

build/ 目录的特殊之处在于它不得提交到源代码控制系统中。用户下载代码库时不应在项目根目录中看到 build/ 目录，但在使用软件的过程中可能会创建此目录。_build/ 目录也被保留。
```
注意：某些构建系统可能会占用 build/ 目录。在这种情况下，应使用 _build/ 目录代替 build/。
```

build/ 目录可用于存储临时构建结果。不允许将此目录用于其他用途。

不允许在根目录中创建额外的目录来存储构建结果。
```
注意：虽然不允许在根目录中创建多个目录，但 build/ 目录的结构和布局并未规定。可以使用 build/ 的多个子目录来存储不同配置的构建结果。
```

## 2.2. include/
```
注意：include/ 和 src/ 目录密切相关。除了本节内容外，请务必阅读 src/ 目录的相关部分。
```

include/ 目录的用途是存放公共 API 头文件。

如果使用 § 3.1.2 合并头文件放置 的方式，则不应使用 include/ 目录。

更多详细信息，请参见 § 3 库源代码布局。

## 2.3. src/
```
注意：src/ 和 include/ 目录密切相关。除了本节内容外，请务必阅读 include/ 目录的相关部分。
```
src/ 目录的用途和内容取决于项目作者选择遵循 § 3.1.2 合并头文件放置 还是 § 3.1.1 分离头文件放置。

更多详细信息，请参见 § 3 库源代码布局。
## 2.4. tests/ 

此目录不是必需的。

tests/ 目录保留用于与项目（非单元）测试相关的源文件。

本文档未规定此目录的结构和布局。

如果一个项目可以嵌入到另一个项目中（例如通过 § 2.6 external/），则在其检测到作为嵌入式子项目构建时，必须禁用其 tests/ 目录。

项目维护者必须提供一种方式，让使用者能够禁用测试的编译和运行，特别是为了嵌入的目的。
## 2.5. examples/ 

此目录不是必需的。

examples/ 目录保留用于与项目示例和演示代码相关的源文件。本文档未规定此目录的结构和布局。

项目维护者必须提供一种方式，让使用者能够禁用示例和演示代码的编译。

## 2.6. external/
此目录不是必需的。

external/ 目录保留用于嵌入外部项目。每个嵌入的项目应占据 external/ 的一个子目录。

external/ 不应包含工具所需的文件以外的内容。

此目录可能会在构建过程中由工具（例如 git 子模块）自动填充部分或全部内容。在这种情况下，项目必须声明相关源代码控制系统忽略自动填充的子目录。

external/ 的子目录不应作为常规项目开发的一部分进行修改。子目录应尽可能保持与其上游源代码一致。
## 2.7. data/ 

此目录不是必需的。

data/ 目录用于存放应包含在版本控制中但不明确属于代码的项目文件。例如，图形和本地化文件与项目的其他部分不同，但适合放在 data/ 目录中。

本文档未规定此目录的结构和布局。
## 2.8. tools/ 

此目录不是必需的。

tools/ 目录用于存放与项目开发和贡献相关的额外脚本和工具。例如，一键构建脚本、代码检查脚本、代码生成脚本、测试脚本或其他对项目开发有用的工具。

此目录的内容不应与项目使用者相关。
## 2.9. docs/ 

此目录不是必需的。

docs/ 目录用于存放项目文档。本文档未规定文档的编写过程、工具和布局。

## 2.10. libs/ 

除非项目希望将自己划分为子模块，否则不得使用 libs/ 目录。它的存在会排除 src/ 和 include/ 目录。

更多详细信息，请参见 § 4 子模块 和 § 4.3 libs/。
## 2.11. extras/ 

此目录不是必需的。

extras/ 是一个子模块根目录。更多详细信息，请参见 § 4 子模块 和 § 4.4 extras/。

# 3. Library Source Layout
库源代码树指的是组成单个库的源代码文件的布局。库是向库的使用者公开的代码集合。
## 3.1. 头文件放置

本文档支持两种在单个库中放置头文件的方法：分离式和合并式。这两种方法在单个库源代码树中互斥。
### 3.1.1. 分离式头文件放置

在分离式放置中，有两个源代码目录：§ 2.2 include/ 和 § 2.3 src/。include/ 目录用于存放库的公共头文件，而 src/ 目录用于存放可编译的源代码和私有头文件。
```
注意：并非所有项目都必然有私有头文件。
```
在分离式放置中，单个物理组件被拆分到两个目录中。src/ 目录中可编译源文件的父目录的相对路径必须与 include/ 目录中对应头文件的父目录的相对路径相同。

EXAMPLE_3
例如，给定一个头文件 meow.hpp 和一个源文件 meow.cpp 的物理组件，我们可以将头文件放置在 include/cat/sounds/meow.hpp。从 include/ 到 meow.hpp 父目录的相对路径是 cat/sounds。

因此，我们可以将可编译源文件的路径构造为：将源目录名称 src、相对路径 cat/sounds 和文件名 meow.cpp 连接起来，得到路径 src/cat/sounds/meow.cpp。最终的布局如下：
```
<root>/
    include/
        cat/
            sounds/
                meow.hpp
    src/
        cat/
            sounds/
                meow.cpp
```
```
注意：确定性头文件/源文件路径关系的目的是帮助工具和人类查看者理解和操作源代码目录结构。
```
```
注意：这些物理组件的相对路径并不是任意的。更多详细信息，请参见 § 3.3 源代码目录布局。
```
使用分离式头文件布局的库的使用者应被提供 § 2.2 include/ 目录的路径，作为库公共接口的唯一包含搜索目录。这样可以防止用户 #include 仅存在于 src/ 目录中的路径。

库本身在编译时应将其 § 2.2 include/ 和 § 2.3 src/ 目录都作为包含搜索目录。这确保库本身可以访问两个源代码目录中的所有文件。

### 3.1.2. 合并式头文件放置
在合并式头文件放置中，只有一个源代码目录：§ 2.3 src/。

与分离式放置类似，从源代码目录到物理组件文件的父目录的相对路径必须相同。这意味着物理组件的文件将始终位于同一目录中。

EXAMPLE_4
例如，给定一个包含头文件 hiss.hpp 和源文件 hiss.cpp 的物理组件，以及相对路径 cat/sounds，最终的布局如下：
```
<root>/
    src/
        cat/
            sounds/
                hiss.hpp
                hiss.cpp
```

## 3.2. 测试放置

本文档区分了单元测试和其他测试。单元测试是粗略对应于源代码中单个单元的测试。这可能是一个物理组件、公共 API 或其组合。单元测试的区分对其放置位置有影响。
### 3.2.1. 合并式测试放置

可选但推荐使用合并式测试放置。在这种方法中，单元测试应只有一个可编译的源文件，并且该文件的名称主干应与被测试物理组件的文件名主干相同，并在其后附加 .test。例如，对于由 meow.hpp 和 meow.cpp 组成的物理组件的测试将被命名为 meow.test.cpp。此单元测试源文件应放置在与被测试物理组件的可编译源文件相同的目录中。因此，当单元有可编译源文件时，单元测试源文件将作为其同级文件出现。
### 3.2.2. 分离式测试放置

如果不使用合并式测试，所有测试应放置在顶级目录 tests/ 中。tests/ 内的布局没有强制要求。

## 3.3. 源代码目录布局

在本节中，include/ 和 src/ 顶级目录都被包含在“源代码目录”的定义中。它们是库源代码树的根目录。之所以这样命名，是因为它们包含源语言（C 和/或 C++）的主要“源文件”。

不应在源代码目录的任何子目录中放置或生成非源代码文件。也就是说，源代码目录的根目录可以包含非源代码文件，但其子目录不应包含。

相反，不应在源代码目录的根目录中放置源代码文件。也就是说，所有源文件必须具有相对于其源代码目录根目录的限定路径。

头文件和源文件应对应于项目的逻辑组件。例如，一个几何库可能包含一个表示圆形的类以及一个头文件和（可选的）源文件。如果该头文件和/或源文件中没有其他逻辑组件，则可以说该逻辑组件是对应源组件的“主组件”。主逻辑组件可以是一个类、函数或它们的某种组合。

源代码树的布局应与项目的命名空间结构紧密对应。

在 C 语言中，没有语言级别的命名空间概念，但有一种约定，即使用“伪”命名空间来限定全局可见的标识符。例如，libfoo 可能定义了一个 foo_create()，其中前缀 foo_ 充当标识符的“命名空间”。为此，可以说命名空间是 foo。

在 C++ 中，由于有语言级别的命名空间，因此不需要以这种方式限定标识符（当使用 C++ 链接时）。相反，这些限定符被放在命名空间中。

假设每个逻辑组件都有一个命名空间，我们可以将该命名空间与定义它的物理组件关联起来。然后，可以使用该命名空间生成一个限定路径，通过该路径可以找到物理组件。通过这种方式，物理组件可以被视为“内容可寻址”的。

源文件应放置在相对于源代码目录的目录中，其中相对路径是通过将组件命名空间的元素连接为中间目录来组成的。源文件的主干名称应与其声明或定义的逻辑组件的名称相对应。

EXAMPLE_5
给定一个逻辑组件 geo::shapes::circle，我们可以使用限定命名空间生成相对路径 geo/shapes，并将组件的主干名称作为文件名的基础，即 circle。因此，定义逻辑组件的源文件的完整路径为 geo/shapes/circle.hpp 和 geo/shapes/circle.cpp。

如果使用 § 3.1.1 分离式头文件放置，则从项目或子模块根目录到头文件的路径为 include/geo/shapes/circle.hpp，而编译源文件的路径为 src/geo/shapes/circle.cpp。

如果使用 § 3.1.2 合并式头文件放置，则头文件将作为同级文件出现在 src/geo/shapes/circle.hpp。

该组件的单元测试将出现在 src/geo/shapes/circle.test.cpp。


在某些情况下，将编译源文件拆分为多个编译源文件，同时保持单个头文件可能是有利的。在这种情况下，源文件的主干名称应与未拆分时相同，然后通过 . 分隔符添加源文件的区分特征。

EXAMPLE_6
给定一个逻辑组件 geo::shapes::circle，以及两个极其复杂的成员函数 circumference() 和 area()，我们可能会将这些方法的实现拆分为单独的翻译单元。生成的物理组件将具有以下结构：
```
<root>
    src/geo/shapes/
        circle.hpp
        circle.cpp
        circle.circumference.cpp
        circle.area.cpp
        circle.test.cpp
```

# 4. 子模块

非常大的项目（例如 Qt、Boost、JUCE、LLVM）将从子模块的概念中受益。

子模块

    一个较大项目的细分部分，可以按需使用。包含自己的源代码树、测试、数据和文档。
```
注意：将项目拆分为子模块时应非常谨慎。这是一个极其复杂的工具，常常让人陷入困境。
很少有项目需要以这种方式进行细分。大多数项目在其源代码树中使用多个命名空间和目录就足够了。当命名空间和子目录已经足够时，不要轻易使用这个工具。
将项目转换为子模块布局或从子模块布局转换回来是一项非常繁琐的任务。
```

在考虑或使用子模块时，必须考虑以下规则：

    子模块本身不是独立的项目。

    它们不应假装是完整的项目。

    它们不能独立于项目的其他部分使用。

    它们不应与项目分开进行版本控制。

    它们不能进一步细分为子子模块。

## 4.1. 子模块根目录

子模块根目录

    一个目录，其子目录是子模块。

子模块根目录包括：

    § 2.11 extras/

    § 4.3 libs/

子模块根目录的每个子目录必须严格对应一个子模块。
## 4.2. 子模块目录

子模块表示为项目的一个子目录，可以包含以下目录：

    src/：用于存放子模块的源代码

    include/：用于存放子模块的头文件（如果分离头文件）

    tests/：用于存放子模块的测试

    data/：用于存放子模块的数据

    examples/：用于存放示例代码

    docs/：用于存放子模块的文档
```
注意：大多数顶级目录未包含在此列表中。
```
子模块目录不应包含工具所需的文件或目录以外的内容。
## 4.3. libs/ 目录

libs/ 目录用于存放主要的子模块。它是一个子模块根目录。

当 libs/ 目录存在时，顶级 src/ 和 include/ 目录不得存在。使用 libs/ 进行子模块划分的项目应重构自身，使项目具有一个共同的基础子模块，其他子模块可以依赖该基础子模块。

libs/ 和 extras/ 的主要区别在于，libs/ 中的子模块应默认构建，尽管使用者可以根据需要选择排除某些子模块。

## 4.4. extras/ 目录

extras/ 目录用于存放项目的附加子模块，这些子模块建立在主要组件之上。这可能包括不属于项目“默认”构建的子模块，或者需要特殊要求才能使用的子模块。

例如，以下内容可能适合放在 extras/ 目录中，而不是常规组件中：

    “语言绑定” 或提供项目与不同于其自身编程语言或运行时集成的额外库。

    “平台绑定” 或提供项目与特定平台集成的额外库（插件）。例如，一个需要了解如何与 Windows、Quartz、X11 和 Wayland 通信的窗口库可能会将其平台集成实现放在此目录中。

    “贡献的”子模块：由项目用户贡献并包含在上游中的额外子模块，但项目不正式支持。

    可选子模块：需要额外依赖项，或者可能不适合所有用户包含的子模块。例如，Qt 的 Webkit 模块构建时间过长，并且需要仅针对该组件的依赖项。

# 5. 构建系统

本文档不强制要求使用任何特定的构建系统。唯一的要求是所选的构建系统支持本文定义的布局。
# 6. 库

对于库项目，源代码树应严格对应一个库。也就是说，最多只有一个可链接的结果，并且只有一个公共包含目录。单个 #include 树不应要求链接多个库来访问从该树导出的所有符号。
```
注意：子模块有自己的源代码树，每个子模块可以包含一个可以独立链接和使用的库。
```
单个源代码树不应基于目标平台以外的任何内容更改其公共接口。这有几个重要的影响，包括（但不限于）以下内容：

    库不应提供用户控制来调整其公共接口。

    库不应基于外部软件的存在/不存在更改其公共接口。